---
title: mysql lock  
date: 2018-09-30 17:01:36  
tags: mysql lock  
categories: 技术

---
### 锁级别
1. 表级锁  
表级锁的开销小，加锁快，不会出现死锁，锁定粒度大，大概率发生锁的冲突，并发度低。
2. 行级锁  
行级锁的开销大，加锁满，会出现死锁，锁定粒度小，小概率发生锁的重读，并发度高。
3. 页级锁  
支持页级锁的BDB引擎已经逐渐被InnoDB替代了，这里暂不讨论。  

上述特点来看，很难说哪种锁更好，只能相对于所处的业务场景来选择更加适合的锁机制。如果仅从锁的角度来看，表级锁更适合以查询为主的应用场景，而行级锁则更适合于大量按索引条件并发更新少量数据的应用场景。

### 锁模式
1. 共享锁(S)  
共享锁是他人可以读但不能写
2. 排他锁(X)
排它锁则会阻塞他人的读写操作

<!-- more -->

为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的**意向锁**（Intention Locks），这两种意向锁都是表锁。  
意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。  
意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。  
上述来看，InnoDB为了实现多粒度锁机制，采用了意向锁。话句话说如果不将表级锁和行级锁有所区别的话，是实现不了多粒度锁机制的。所以我认为意向锁是为了实现锁的层级而发明出来的一种锁。  

#### 意向锁的作用
引进意向锁是为了提高封锁子系统的效率。意向锁的含义是：对任一结点加锁时，必须先对它的上层结点加意向锁。引进意向锁后，系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了。  

这里说说我的看法，我们平时更新某一条数据，肯定会加一个表的IS锁，然后再对这一行加一个行级排他锁。在互联网中并发更新是最常见的场景，这个时候InnoDB是如何判断有没有锁冲突的呢？答案我们稍微考虑下就知道了，表的意向锁肯定不能够判断出来的，最终还是要到那一行中去判断有没有冲突。所以网上经常说的提高了判断锁冲突的效率，这样我并不能理解。或者说，其实是加了IX锁，这样才可能提高效率，但是我理解IX锁会影响其他事务的写入，难道实我理解不对？？？这里我先记录下来。

### 锁的实现方式
InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。
  
由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。  

当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。如果不同的索引碰巧都落到了同一个行上，那么同样会阻塞。  

即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。

这里我做一下补充，InnoDB给某一行数据加锁的时候，肯定是给所有能定位到这行数据的所有索引项加锁的，不然同一行数据，根据不同的索引查找到的话，锁就不能生效了。比如说，一个事务根据id更新，另一个事务根据索引更新。

另外感谢下原作者[https://www.jianshu.com/p/fa28035656a9](https://www.jianshu.com/p/fa28035656a9)、[https://www.jianshu.com/p/325a492a859b](https://www.jianshu.com/p/325a492a859b)。我只是看他们的文章过程中，产生了兴趣和思考。